#!/usr/bin/env bash
# ─────────────────────────────────────────────────────────────────
# tools/convert_model.sh
#
# Converts a .tflite flatbuffer into the model_data.cc C array file
# expected by the wake_word_detection firmware.
#
# Usage:
#   ./tools/convert_model.sh <path/to/model.tflite>
#
# Output:
#   components/model/src/model_data.cc  (overwritten)
# ─────────────────────────────────────────────────────────────────

set -euo pipefail

TFLITE="${1:-}"
if [[ -z "$TFLITE" || ! -f "$TFLITE" ]]; then
    echo "Usage: $0 <path/to/model.tflite>"
    exit 1
fi

OUTFILE="$(dirname "$0")/../components/model/src/model_data.cc"
OUTFILE="$(realpath "$OUTFILE")"

echo "[convert_model] Input : $TFLITE"
echo "[convert_model] Output: $OUTFILE"

SIZE_BYTES=$(wc -c < "$TFLITE" | tr -d ' ')
echo "[convert_model] Model size: ${SIZE_BYTES} bytes"

# Generate the raw xxd output then massage it into our expected format
TMPFILE=$(mktemp)

xxd -i "$TFLITE" > "$TMPFILE"

cat > "$OUTFILE" << 'HEADER'
/**
 * @file model_data.cc
 * @brief MicroWakeWord TFLite flatbuffer — auto-generated by convert_model.sh
 *
 * DO NOT EDIT MANUALLY.  Regenerate with:
 *   ./tools/convert_model.sh <model.tflite>
 */

#include "model_data.h"

__attribute__((aligned(8)))
HEADER

# Extract just the hex array body (strip first and last lines of xxd output)
# xxd produces:
#   unsigned char foo_tflite[] = { 0x1c, … };
#   unsigned int  foo_tflite_len = NNNN;
#
# We replace those with our canonical names.

# Grab the array line (everything between { and };)
ARRAY_BODY=$(grep -v "^unsigned int" "$TMPFILE" | \
             sed 's/^unsigned char .*= {/const uint8_t g_model_data[] = {/')

echo "$ARRAY_BODY" >> "$OUTFILE"
echo "" >> "$OUTFILE"
echo "const size_t g_model_data_len = sizeof(g_model_data);" >> "$OUTFILE"

rm -f "$TMPFILE"

echo "[convert_model] Done. Lines written: $(wc -l < "$OUTFILE")"
echo "[convert_model] Build with: idf.py build"
